\subsection{Aprakstu stili} \label{sec:hdl-styles}
Vienādas komponentes HDL parasti var aprakstīt vairākos veidos.
HDL aprakstus var sadalīt divos pieraksta stilos, pēc problēmas pieejas un
no valodas konstrukciju kopas kas šai pieejai raksturīga.
\begin{enumerate}
	\item \textbf{Strukturālais} pieraksta stils --- komponentes tiek
		izveidotas izmantojot vienkāršākas apakškomponentes un aprakstot 
		to savstarpējos
		savienojumus. Šis stils uzskatāms par tekstuālu analogu
		tradicionālajam, shematiskajam izstrādes veidam.
	\item \textbf{Funkcionālās} jeb izturēšanās modelēšanas pieraksta
		stils --- komponentes tiek izveidotas aprakstot shēmas funkcionalitāti
		abstrahējoties no tās iespējamās uzbūves.
	\begin{itemize}
		\item \textbf{Secīgās izturēšanās} pieraksta stils --- apakškopa
			no funkcionālā stila, kurā izmantotas konstrukcijas, kas ļauj
			komponentes darbību aprakstīt ar secīgām izpildāmām izteiksmēm,
			līdzīgi imperatīvām programmēšanas valodām (kā C, Python, u.c.),
			pretstatā paralēli izpildāmām datu plūsmas izteiksmēm.
	\end{itemize}
\end{enumerate}
\pagebreak[3]

Šie stili ne tikai ietekmē koda (konkrētā shēmas apraksta teksta) pierakstu,
bet arī simulācijas un sintēzes procesus, kuriem šis pieraksts ir jāinterpretē.
Strukturālā pieraksta un tādu funkcionālā pieraksta primitīvu konstrukciju,
kā loģisko elementu (\texttt{UN}, \texttt{VAI}, utt.)
sintēze ir tieši translējama uz aparatūras komponentēm un to savienojumiem.
Savukārt, sarežģītu funkcionālo konstrukciju (jo sevišķi secīgo
konstrukciju) sintēzei nepieciešams veikt speciālu funkcionalitātes apraksta
translāciju uz konkrētu aparatūras implementāciju, t.i.,~sintēzes rīkam nepieciešams
piemeklēt aparatūras komponentes, kas realizētu konkrēto funkcionalitāti.
Tā kā funkcionalitātes un implementācijas saistība bieži nav viennozīmīga,
dažādu sintēzes rīku interpretācija vienādam kodam var stipri atšķirties.

Praktiski visi sintēzes rīki funkcionālo pierakstu translē %uz aparatūras 
reģistru datu pārraides abstrakcijas līmenī jeb RTL
(no angļu \termEn{Register tranfer level}) \cite[2.~lpp.]{HDL}%
\cite[235.~lpp.]{Perry-VHDL}.
RTL abstrakcijas vienību (elementu) veido kombinacionālās datu transformācijas shēma un
datu uzglabāšanas reģistrs (sk.~\ref{fig:rtl}~att.).
\begin{figure}[thb]
	\centering
	%\def\svgwidth{7cm}
	\def\svgscale{1.25}
	\input{img/rtl-unit.pdf_tex}
	\caption[RTL abstrakcijas vienība.]{RTL abstrakcijas vienība \cite[233.~lpp.]{Perry-VHDL}.}
	\label{fig:rtl}
\end{figure}
Izstrādājot ierīci sintēzei ar HDL kodu, tiek bieži pieminēts
,,RTL apraksta stils''. Šis stils ir HDL konstrukciju kopa, kas
pakļaujas sintēzei un iekļauj visas strukturālā stila konstrukcijas, kā arī
lielu daļu funkcionālā stila konstrukcijas.

Jāuzsver gan, ka RTL pieraksta stils nepieprasa, lai katrai aprakstītai
komponentei būtu piekārtojams tieši viens RTL elements. Vienas komponentes
apraksts var saturēt vairākus RTL elementus, kā arī viens RTL elements var
pārklāt vairākas komponentes. Kā piemēru pēdējam variantam, var apskatīt
darba praktiskajā daļā izstrādāto mikrokontroliera datu kalkulācijas
signālceļu (sk.~\ref{fig:rtl-alu}~att.).
\begin{figure}[thb]
	\centering
	\def\svgwidth{0.9\textwidth}
	%\def\svgscale{1.25}
	{\ttfamily\scriptsize\input{img/rtl-alu.pdf_tex}}
	\caption{RTL sadalījuma piemērs ALU signālceļam.}
	\label{fig:rtl-alu}
\end{figure}
Šeit \texttt{alu} (Aritmētiski loģiskā ierīce) un \texttt{shift}
(Bitu bīdes loģiskā ierīce) ir kombinacionālās shēmas, bez iekšējiem atmiņas
elementiem, savukārt \texttt{reg} (Reģistrs), kura uzdevums ir saglabāt kalkulācijas
rezultātu, acīmredzami, ir reģistra jeb atmiņas daļa šajā RTL elementa piemērā.
Tādējādi šīs trīs komponentes veido vienu RTL elementu.

Konstrukcijas, kuras nav translējamas RTL, sauc --- visai aprakstoši --- par 
,,tikai simulējamām konstrukcijām''. Tās nav sintezējamas un tiek
izmantotas simulācijas ietvaros. Viena no vienkāršākajām un biežāk
izmantotajām ir novēlotā signāla piešķire, piem.,~VHDL izteiksme 
|q <= a after 10 ns;| piešķir |a| vērtību signālam |q| pēc 10 nanosekundēm.
Tas ir labs veids, kā simulēt komponenšu aiztures, bet tiks ignorēta
sintēzē, jo elementiem, ar kuriem tiks realizēta shēma, piemīt
konkrēta aizture, ko nosaka to fiziskā uzbūve.

Svarīgi piezīmēt, ka pretstatā sintēzes rīkam, simulatoram nav nepieciešama
pieraksta translācija RTL. Tā kā simulācija notiek
programmatūras līmenī, vairumā gadījumu secīgās izturēšanās modeli
simulatoram ir vienkāršāk (un tādējādi arī ātrāk) simulēt nekā paralēli
izpildāmās konkurentās konstrukcijas.
