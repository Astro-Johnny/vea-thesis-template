\subsection{Komponentes}
Izstrādātais procesors (mikrokontroliera kodols) sastāv no vairākām
apakš\-kom\-po\-nentēm (sk.~\ref{fig:cpu-rev3}~att., \pageref{fig:cpu-rev3}~lpp.). 
Šo komponenšu uzbūve un darbība aprakstīta sintēzei
derīgā ,,RTL stila'' VHDL apraksta kodā izmantojot tikai standarta un
paša izveidotas pakotnes,
šādi panākot augstu implementācijas portabilitāti%
	\footnote{Iespējamu projekta izmantošanu dažādos izstrādes rīkos.}.
Lai izvairītos no ,,skriešanās problēmām'' (\termEn{race condition})
simulācijas laikā un arī simulētu signālu aizkavēšanos,
VHDL aprakstos visai bieži izmantota novēlotās piešķiršanas konstrukcija,
kuru sintēzes rīks ignorē.

Komponenšu VHDL aprakstos piesaukti tipi un konstantes no paša definētas
\texttt{cpu\_lib} pakotnes, kas redzama sekojošā koda blokā.
\begin{singlespace}
\lstinputlisting[language={[qucs]VHDL},%float=b,%
                 caption={Procesora \texttt{cpu\_lib} pakas definīcija (\texttt{cpu\_lib.vhd}).},%
                 label=kb:cpulib,basicstyle=\ttfamily\scriptsize]
	{code/cpu_lib.vhd}
\end{singlespace}
\pagebreak[3]

\FloatBarrier
\subsubsection{Reģistri}
	Viena no vienkāršākajām komponentēm ir reģistrs.
	Tā funkcija ir uzglabāt	viena mašīn\-vārdu datus 
	(šajā gadījumā 16 bitu vārda) un pārrakstīt to pēc
	pieprasījuma. Implementētais reģistrs ir sinhrons un dinamisks, un tā
	dati tiek pārrakstīti \texttt{clk} signālam pārejot no zema uz augstu
	stāvokli.
	\begin{figure}[bh]
		\centering
		%\def\svgwidth{7cm}
		\def\svgscale{1.25}
		{\ttfamily\scriptsize\input{img/sub-reg.pdf_tex}}
		\caption{Reģistrs.}
		\label{fig:reg}
	\end{figure}
	
	Reģistra VHDL apraksts ir visai triviāls un, ar nelielām izmaiņām
	(sk.~\ref{kb:reg}~pirmkodu),
	izmantots D.~Perija paraugs.\cite[321.~lpp.]{Perry-VHDL}
	%\begin{singlespace}
	% NOTE: No Need for singlespace when floated!
		\lstinputlisting[language={[qucs]VHDL},float=thb,%
		                caption={Reģistra VHDL apraksts. (\texttt{reg.vhd})},%
		                label=kb:reg]
			{code/reg.vhd}
	%\end{singlespace}
	
	\pagebreak[2]
	Lai gan reģistrs ir vienkārša ierīce, to plaši izmanto procesora
	realizācijā, uzglabājot ļoti dažādas nozīmes datus.
	Šī darba ietvaros izstrādātajā procesorā ir sekojoši speciālās nozīmes reģistri:
	\pagebreak[1]
	\begin{itemize}
		\item \textbf{Programmskaitītājs} (\texttt{PC}):
			Reģistrs, kas uzglabā adresi aktīvajai programmas pozīcijai,
			t.i.~parasti izpildāmās instrukcijas adresi. Secīgās programmas
			izpildes laikā \texttt{PC} tiek inkrementēts%
			\footnote{Konkrētāk — \texttt{PC} tiek palielināts par
				izpildīto instrukcijas vārdu skaitu (1 vai 2).},
			savukārt lēcieni (zarošanās)
			programmā realizēti pārrakstot programmskaitītāja saturu.\pagebreak[2]
		\item \textbf{Izpildāmās instrukcijas reģistrs} (\texttt{instrReg})
			ieraksta izpildāmās instrukcijas kodu.
			Nepieciešams, lai kontroles stāvokļa mašīna „neaizmirstu”
			izpildāmo operāciju un tās argumentus izpildot
			turpmākās mikro\-operācijas%
			\footnote{Mikrooperācijas ir soļi kas jāveic vienas instrukcijas
				izpildei. Kontroles iekārtas stāvokļi atbilst mikrooperācijām
				(sk.~kodu pielikumā \ref{appx:control}).}.
			Divu vārdu instrukcijām saglabāts
			tiek tikai pirmais vārds, jo tikai tajā ir dekodējamais
			operācijas kods. Otrais vārds satur tikai argumentus.
		\item \textbf{Atmiņas adresācijas reģistrs} (\texttt{addrReg})
			uzglabā adresējamo atmiņas adresi tās nolasei
			vai ierakstei. Nepieciešams, lai saglabātu adresi izpildot
			\mnem{LD} un \mnem{ST} instrukcijas (sk.~\ref{sec:instrSet}~nod.),
			%jo tikai viens no diviem iesaistītajiem operatīvajiem reģistriem
			jo tikai viens no diviem iesaistītajiem vispārējas nozīmes reģistriem
			(sk.~\ref{sec:regArray}~nod.) ir nolasāms vai pārrakstāms
			vienā mikrooperācijas solī.
		\item \textbf{Operanda reģistrs} (\texttt{opReg})
			uzglabā vienu no aritmētiskās/loģiskās darbības
			ope\-ran\-diem. Nepieciešams, jo ALU neuzglabā pievadītos
			operandus\footnote{ALU ir realizēta kā kombinacionāla shēma.}
			un abi operandi nolasāmi no tā paša datu avota.
			(par ALU sk.~\ref{sec:alu}~nod., \pageref{sec:alu}~lpp.)
		\item \textbf{Rezultāta reģistrs} (\texttt{outReg}),
			kurā ieraksta aritmētiskās/loģiskās darbības rezultātu.
			Tā kā ALU datu avots var būt (un parasti ir) arī rezultāta
			ierakstes mērķis, rezultāta reģistrs novērš 
			,,skriešanās problēmu'', kas būtu
			iespējama vienlaicīgi lasot un pārrakstot datu avotu.
	\end{itemize}

\pagebreak[3]
\FloatBarrier
%\subsubsection{Operatīvo reģistru masīvs}
\subsubsection{Vispārējas nozīmes reģistru masīvs} \label{sec:regArray}
	Vispārējas nozīmes reģistri ir reģistru kopa, kura, atšķirībā no
	iepriekš apskatītajiem procesora specializētajiem reģistriem,
	ir pieejama	programmētājam tiešai modifikācijai.
	Šiem reģistriem nav noteikta specializēta nozīme,
	tā vietā programmētājs tos lieto pēc vajadzības, piem.~izpildāmās
	programmas mainīgo uzglabāšanai.
	\begin{figure}[th]
		\centering
		%\def\svgwidth{7cm}
		\def\svgscale{1.25}
		{\ttfamily\scriptsize\input{img/sub-regArray.pdf_tex}}
		\caption{Reģistru masīvs.}
		\label{fig:regArray}
	\end{figure}
	
	Vispārējas nozīmes reģistru masīvs ir izpild\-programmas datu apstrādes
	krustpunkts. Tas ir tādēļ ka izstrādātais procesors, 
	līdzīgi vairumam RISC tipa arhi\-tek\-tūru,
	izmanto \termEn{Load/Store} principu, t.i.~visas aritmētiskās darbības
	tiek veiktas ar vispārējas nozīmes reģistriem un datu apmaiņa ar atmiņu (RAM)
	notiek tikai caur šiem reģistriem izmantojot datu apmaiņas
	instrukcijas\cite[11.~lpp.]{Flynn-arch}, šajā gadījumā \mnem{LD} un \mnem{ST}.
	
	%\begin{singlespace}
		\lstinputlisting[language={[qucs]VHDL},float=thb,%
		                caption={Reģistru masīva VHDL apraksts. (\texttt{regarray2.vhd})},%
		                label=kb:regArray,%
		                emph={t_ram}]
			{code/regarray2.vhd}
	%\end{singlespace}
	%\pagebreak[2]
	Realizācijā, kura redzama \ref{kb:regArray} pirmkoda blokā, 
	reģistru masīvs vairāk līdzinās 8 vārdu operatīvajai
	atmiņai, bet netiek realizēta rakstīšanas vai lasīšanas režīma
	pārslēgšana. Tā vietā ir ieejas un izejas pieslēgvietas un
	ierakstītie dati tiek saglabāti un uzreiz izlikti uz izvadi.
	
	Reģistru skaitu masīvā ierobežo pieejamais bitu skaits operācijas
	koda vārdā reģistra adreses\footnote{Vispārējas nozīmes reģistriem ir
		sava, neatkarīga adrešu telpa.}
 	uzglabāšanai. Konkrēti \mnem{AR} instrukcijai pieejami 3 biti reģistra
 	adresei, kas ierobežo vispārējās nozīmes reģistru skaitu līdz 8
 	(unikālo adrešu skaits 3 bitos).

\pagebreak[3]
\FloatBarrier
\subsubsection{Multipleksors}
	Multipleksors praktiski ir elektroniski kontrolēts ,,slēdzis'',
	kas pārslēdz divas vai vairāk ieejas uz vienu izeju. Ieejas un izejas
	ne obligāti ir viens signālvads (bits). Šajā gadījumā tiek pārslēgtas
	16 bitu platas datu maģistrāles, kur
	multipleksors tiek izmantots datu šinā, noslēdzot sazarojumu,
	lai pārslēgtu datu ieejas avotu aiz tā sekojošai komponentei
	(vai komponentēm).
	\begin{figure}[bhp]
		\centering
		%\def\svgwidth{7cm}
		\def\svgscale{1.25}
		{\ttfamily\scriptsize\input{img/sub-mux.pdf_tex}}
		\caption{2 ieeju multipleksors.}
		\label{fig:mux2}
	\end{figure}
	
	Multipleksors realizēts ar ļoti vienkāršu izejas vārda nosacījuma
	pārslēgšanu (sk.~\ref{kb:mux}~pirmkodu).
	%\begin{singlespace}
		\lstinputlisting[language={[qucs]VHDL},float=thb,%
		                 caption={Multipleksora VHDL apraksts (\texttt{mux.vhd}).},%
		                 label=kb:mux]
			{code/mux.vhd}
	%\end{singlespace}

\pagebreak[3]
\FloatBarrier
\subsubsection{Aritmētiski loģiskā ierīce} \label{sec:alu}
	Aritmētiski loģiskā ierīce jeb ALU ir viena no galvenajām
	procesora komponentēm. Tās uzdevums ir veikt doto datu apstrādi un,
	šī procesora realizācijā, arī
	palielināt programmskaitītāju secīgas programmas izpildes nodrošināšanai.
	\begin{figure}[thp]
		\centering
		%\def\svgwidth{7cm}
		\def\svgscale{1.25}
		{\ttfamily\scriptsize\input{img/sub-alu.pdf_tex}}
		\caption{Aritmētiski loģiskā ierīce.}
		\label{fig:alu}
	\end{figure}
	
	Lai gan klasiski bīdes operācijas arī tiek realizētas ALU,
	šajā gadījumā ALU veic tikai aritmētiskās un bitu
	loģikas darbības, atstājot bīdes operācijas „Bitu bīdes loģiskjai ierīcei”
	(sk.~\ref{sec:shifter}~nod.). Šāda sadalīšana ļauj veikt aritmētiskās
	un bīdes operācijas vienlaicīgi, uz ko balstās \mnem{AR} instrukcija
	(sk.~\ref{sec:AR}~nod.~\pageref{sec:AR}~lpp.).
	
	ALU realizēta kā kombinacionāla shēma ar asinhronu darbību,
	t.i.~izejas vērtība tiek izmainīta uzreiz,
	bez kontroles signāla (takts) pievadīšanas, un izejas vērtība ir tikai
	atkarīga no pievadīto operandu vērtībām, kuru vērtības iekšēji ALU
	netiek saglabātas.
	Lai būtu iespējams veikt darbības ar diviem
	operandiem no operatīvo reģistru masīva, tiek izmantots \texttt{opReg}
	reģistrs viena operanda uzglabāšanai, lai otru varētu nodot tieši.
	(sk.~\ref{fig:cpu-rev3}~att., \pageref{fig:cpu-rev3}~lpp.)
	
	\begin{singlespace}
		\lstinputlisting[language={[qucs]VHDL},%float=th,%
		                caption={ALU VHDL apraksts. (\texttt{alu.vhd})},%
		                label=kb:alu]
			{code/alu.vhd}
	\end{singlespace}
	
	ALU veic operācijas ar 16 bitu vārdiem, kuri reprezentē bezzīmes
	skaitļus. ALU VHDL implementācija izmanto \texttt{std\_logic\_unsigned}
	pakotnē	definētās aritmētiskās operācijas,
	ievērojami vienkāršojot ALU VHDL aprakstu (sk.~\ref{kb:alu}~pirmkodu).

\pagebreak[3]
\FloatBarrier
\subsubsection{Bitu bīdes loģiskā ierīce} \label{sec:shifter}
	Ierīce, kura šeit nosaukta par ,,Bitu bīdes loģisko ierīci'',
	realizē bitu bīdes operācijas, kuras šī procesora realizācijā ir
	izdalītas atsevišķi no ALU. 

	\begin{figure}[h!]
		\centering
		%\def\svgwidth{7cm}
		\def\svgscale{1.25}
		{\ttfamily\scriptsize\input{img/sub-shift.pdf_tex}}
		\caption{Bitu bīdes loģiskā ierīce.}
		\label{fig:shift}
	\end{figure}
	
	Realizācija, līdzīgi ALU, ir kombinacionāla un asinhrona. Ieejošie dati
	tiek pārbīdīti atkarībā pēc |sel| signāla stāvokļa 
	(sk.~\ref{kb:shifter}~pirmkodu).
	
	%\begin{singlespace}
		\lstinputlisting[language={[qucs]VHDL},float=th,%
		                caption={Bīdes ierīces VHDL apraksts. (\texttt{shifter.vhd})},%
		                label=kb:shifter]
			{code/shifter.vhd}
	%\end{singlespace}
	
	

%\clearpage
\pagebreak[3]
\FloatBarrier
\subsubsection{Komparators} \label{sec:comp}
	Komparators jeb salīdzinātājs ir komponente, kas salīdzina 
	divus operandus --- 16 bitu vārdus, kas tiek interpretēti kā bezzīmes
	skaitļi.
	Šī komparatora implementācija ir minimizēta, kombinacionāla un nesatur
	kontroles signālus (salīdzinājumam ar D.~Perry realizāciju sk.~\todo{}~nod.).
	Izvadīti tiek tikai divi loģiskie signāli, no kuriem |eq|
	norāda uz operandu vienādību (loģiskais |1|) vai nevienādību (loģiskā |0|),
	savukārt |gr| norāda vai operands \texttt{a} ir lielāks (|1|)
	par \texttt{b} vai nav (|0|). Ar šo
	informāciju ir pilnīgi pietiekami, lai būtu iepējams realizēt visas
	nosacījuma zarošanās (\mnem{BRxx}) instrukcijas
	(sk.~\ref{sec:branching}~nod.~\pageref{sec:branching}~lpp.).
	\begin{figure}[bhp]
		\centering
		%\def\svgwidth{7cm}
		\def\svgscale{1.25}
		{\ttfamily\scriptsize\input{img/sub-comp.pdf_tex}}
		\caption{Komparators.}
		\label{fig:comp}
	\end{figure}
	
	%\begin{singlespace}
		\lstinputlisting[language={[qucs]VHDL},float=thbp,%
		                %basicstyle=\ttfamily\scriptsize,%
		                caption={Komparatora VHDL apraksts. (\texttt{comp.vhd})},%
		                label=kb:comp]
			{code/comp.vhd}
	%\end{singlespace}

%\clearpage
%\FloatBarrier
\pagebreak[3]
\subsubsection{Kontroles iekārta} \label{sec:control}
	Viena no galvenajām procesora komponentēm ir kontroles iekārta, kas,
	iespējams, ir procesora sarežģītākā komponente. Kontroles iekārta
	nodrošina mikrooperāciju izpildi, kas kontrolē datu plūsmu starp
	procesora iekšējām komponentēm un datu apmaiņu ar RAM.
	\begin{figure}[hp]
		\centering
		%\def\svgwidth{7cm}
		\def\svgscale{1.1}
		{\ttfamily\scriptsize\input{img/sub-control.pdf_tex}}
		\caption{Kontroles iekārta.}
		\label{fig:control}
	\end{figure}
	
	Kontroles iekārta realizēta kā stāvokļa mašīna, kur katrs stāvoklis
	atbilst vienai mikrooperācijai, un, tātad, tās VHDL apraksts var tikt
	uzskatīts par analogu mikrokodam. Viena mikrooperācija tiek
	izpildīta vienā takts ciklā.
	
	Kontroles iekārta instrukcijas izpilda pa vienai, izdarot sekojošas
	soļus katras instrukcijas izpildē:
	\begin{enumerate}
		\item \textbf{instrukcijas ielase} (1 mikroop.) nolasa operācijas kodu no RAM
			un saglabā to turpmākai dekodēšanai;
		\item \textbf{instrukcijas dekodēšana} (1 mikroop.) pēc operācijas
			koda nosaka nepieciešamās mikrooperācijas konkrētai instrukcijas
			izpildei; %\footnote{Konkrēti tikai jānosaka viena nākamā izpildāmā
				%mikrooperācija, jo aiz tās sekojošas mikroop.~izpildās jau
				%noteiktā kārtībā};
		\item \textbf{datu ielase un operācijas izpilde} (0--7 mikroop.)
			veic instrukcijas specifiskās operācijas, kas var iekļaut
			nevienu, vienu vai vairākas no sekojošām operācijām:
			\begin{itemize}
				\item datu ielase no RAM;\footnote{%
					Datu nolase var aizņemt vairākus takts ciklus līdz
					atmiņa ir gatava datu pārraidei (\texttt{ready} tiek pacelts).}
				\item datu ierakste RAM;
				\item aritmētiskā un/vai bīdes operācija;
				\item zarošanās nosacījuma pārbaude;
				\item programmskaitītāja pārrakstīšana zarošanās izpildei;
			\end{itemize}\pagebreak[1]
		\item \textbf{programmskaitītāja inkrementācija} veic sagatavošanos
			nākamās instrukcijas izpildes ciklam.
	\end{enumerate}
	
	Kontroles iekārtas kods ir pārāk apjomīgs un komplicēts, lai to
	apskatītu šeit, tādēļ atsevišķas tā daļas tiks izskatītas turpmākajās
	nodaļās un pilnais kods iekļauts pielikumā~\ref{appx:control}
