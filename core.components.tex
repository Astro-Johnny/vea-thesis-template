\subsection{Komponentes}
Instrādātais procesors --- mikrokontroliera kodols --- sastāv no vairākām
apakš\-kom\-po\-nentēm (sk.~\ref{fig:cpu-rev3}~att., \pageref{fig:cpu-rev3}~lpp.). 
Šo komponenšu uzbūve un darbība aprakstīta sintēzei
derīgā, RTL (\termEn{Register Transfer Level}) stila VHDL apraksta kodā.

RTL stila VHDL apraksts panāk augstu implementācijas portabilitāti%
	\footnote{Iespējamu projekta izmantošanu dažādos izstrādes rīkos.}%
, lai gan dažas komponentes, veiktspējas palielināšanas nolūkos, ir
izveidotas izmantojot izstrādes rīka ,,Actel Libero'' makrosus.

\subsubsection{Reģistri}
	Viena no vienkāršākajām komponentēm ir reģistrs.
	Tā funkcija ir uzglabāt	viena mašīn\-vārda datus 
	— šajā gadījumā 16 bitu vārda — un atjaunot to pēc
	pieprasījuma (ar \texttt{clk} signālu).
	\begin{figure}[bh]
		\centering
		%\def\svgwidth{7cm}
		\def\svgscale{1.25}
		{\ttfamily\scriptsize\input{img/sub-reg.pdf_tex}}
		\caption{Reģistrs.}
		\label{fig:reg}
	\end{figure}
	
	Reģistra VHDL apraksts ir visai triviāls un, ar nelielām izmaiņām,
	izmantots D.~Perija paraugs.\cite[321.~lpp.]{Perry-VHDL}
	%\begin{singlespace}
	% NOTE: No Need for singlespace when floated!
		\lstinputlisting[language={[qucs]VHDL},float=hb,%
		                caption={Reģistra VHDL apraksts. (\texttt{reg.vhd})},%
		                label=kb:reg]
			{code/reg.vhd}
	%\end{singlespace}
	
	\pagebreak[3]
	Lai gan reģistrs ir vienkārša ierīce, to plaši izmanto procesora
	realizācijā, uzglabājot ļoti dažādas nozīmes datus.
	Šī darba ietvaros izstrādātajā procesorā ir sekojoši speciālās nozīmes reģistri:
	\begin{description}
		\item[\texttt{PC} — Programmskaitītājs] \hfill \\
			Reģistrs, kas uzglabā adresi aktīvajai programmas pozīcijai,
			t.i.~parasti izpildāmās instrukcijas adresi. Secīgās programmas
			izpildes laikā \texttt{PC} tiek inkrementēts%
			\footnote{Konkrētāk — \texttt{PC} tiek palielināts par
				izpildīto instrukcijas vārdu skaitu (1 vai 2).},
			savukārt lēcieni (zarošanās)
			programmā realizēti pārrakstot programmskaitītāja saturu.
		\item[\texttt{instrReg} — Instrukciju reģistrs] \hfill \\
			Reģistrs, kurā ieraksta izpildāmo instrukcijas kodu.
			Nepieciešams, lai kontroles stāvokļa mašīna „neaizmirstu”
			izpildāmo operāciju un tās argumentus izpildot
			turpmākās mikro\-operācijas.
		\item[\texttt{addrReg} — Atmiņas adresācijas reģistrs] \hfill \\
			Reģistrs, kurā ieraksta adresējamo atmiņas adresi tās nolasei
			vai ierakstei. Nepieciešams lai izvairītos no
			cirkulārās loģikas ielasot datus no atmiņas.
			\todo % TODO: Ieliec atsauci, vai pilnu izskadrojumu
		\item[\texttt{opReg} — Operanda reģistrs] \hfill \\
			Reģistrs, kas uzglabā vienu no aritmētiskās/loģiskās darbības
			ope\-ran\-diem. Nepieciešams, jo ALU neuzglabā pievadītos
			operandus\footnote{ALU ir realizēta kā kombinacionāla shēma.}
			un abi operandi nolasāmi no tā paša datu avota.
			(par ALU sk.~\ref{sec:alu}~nod., \pageref{sec:alu}~lpp.)
		\item[\texttt{outReg} — Izejas reģistrs] \hfill \\
			Reģistrs, kurā ieraksta aritmētiskās/loģiskās darbības rezultātu.
			Nepieciešams lai izvairītos no cirkulārās loģikas
			ierakstot rezultātu operatīvajos reģistros.
	\end{description}

\pagebreak[3]
\subsubsection{Operatīvo reģistru masīvs}
	Operatīvie reģistri ir adresējama reģistru kopa, kura, atšķirībā no
	iepriekš apskatītajiem procesora specializētajiem reģistriem,
	ir pieejama	programmētājam tiešai modifikācijai.
	Tos sauc arī par vispārēja pielietojuma reģistriem, 
	jo tiem nav noteikta specializēta nozīme.
	Tā vietā programmētājs tos lieto pēc vajadzības, piem.~izpildāmās
	programmas mainīgo uzglabāšanai.
	\begin{figure}[t!]
		\centering
		%\def\svgwidth{7cm}
		\def\svgscale{1.25}
		{\ttfamily\scriptsize\input{img/sub-regArray.pdf_tex}}
		\caption{Reģistru masīvs.}
		\label{fig:regArray}
	\end{figure}
	
	Operatīvo reģistru masīvs ir izpild\-programmas datu apstrādes
	krustpunkts. Tas ir tādēļ ka izstrādātais procesors, 
	līdzīgi vairumam RISC arhitektūru,
	izmanto \termEn{Load/Store} principu, t.i.~visas aritmētiskās darbības
	tiek veiktas ar operatīvajiem reģistriem un datu apmaiņa ar atmiņu (RAM)
	notiek ar tikai caur operatīvajiem reģistriem izmantojot datu apmaiņas
	instrukcijas\cite[11.~lpp.]{Flynn-arch}, šajā gadījumā \mnem{LD} un \mnem{ST}.
	
	%\begin{singlespace}
		\lstinputlisting[language={[qucs]VHDL},float=t!,%
		                caption={Reģistru masīva VHDL apraksts. (\texttt{regarray2.vhd})},%
		                label=kb:regArray,%
		                emph={t_ram}]
			{code/regarray2.vhd}
	%\end{singlespace}
	%\pagebreak[2]
	Šajā realizācijā, reģistru masīvs vairāk līdzinās 8 vārdu operatīvajai
	atmiņai, bet netiek realizēta rakstīšanas vai lasīšanas režīma
	pārslēgšana. Tā vietā ir ieejas un izejas pieslēgvietas, kur
	ierakstītie dati tiek saglabāti un uzreiz izlikti uz izvadi.

\pagebreak[3]
\subsubsection{Multipleksors}
	Multipleksors praktiski ir elektroniski kontrolēts slēdzis,
	kas pārslēdz divas vai vairāk ieejas uz vienu izeju. Ieejas un izejas
	ne obligāti gan ir viens ,,vads'' (bits). Šajā gadījumā tiek pārslēgti
	16 bitu platas datu maģistrāles, kur
	multipleksors tiek izmantots datu šinā, noslēdzot sazarojumu,
	lai pārslēgtu datu ieejas avotu aiz tā sekojošai komponentei
	(vai komponentēm).
	\begin{figure}[thp]
		\centering
		%\def\svgwidth{7cm}
		\def\svgscale{1.25}
		{\ttfamily\scriptsize\input{img/sub-mux.pdf_tex}}
		\caption{2 ieeju multipleksors.}
		\label{fig:mux2}
	\end{figure}
	
	Multipleksors, veiktspējas uzlabošanas nolūkos, realizēts ar
	\termEn{Actel Libero} programmatūras pieejamo multipleksora makrosu,
	kura instancējamā VHDL entītijas definīcija parādīta \ref{kb:mux}~koda blokā.
	VHDL arhitektūra ir programmatūras rīka definēta un	tādēļ netiek parādīta.
	%\begin{singlespace}
		\lstinputlisting[language={[qucs]VHDL},float=hb,%
		                 caption={Multipleksora makrosa entītijas definīcija.},%
		                 label=kb:mux,%
		                 linerange={8-12},firstnumber=8]
			{code/gen/muxiitis.vhd}
	%\end{singlespace}

\pagebreak[3]
\subsubsection{Aritmētiski loģiskā ierīce} \label{sec:alu}
	Aritmētiski loģiskā ierīce jeb ALU ir viena no galvenajām,
	procesora definējošām
	komponentēm. Tās uzdevums ir veikt doto datu apstrādi, kā arī
	palielināt programmskaitītāju secīgas programmas izpildes nodrošināšanai.
	\begin{figure}[thp]
		\centering
		%\def\svgwidth{7cm}
		\def\svgscale{1.25}
		{\ttfamily\scriptsize\input{img/sub-alu.pdf_tex}}
		\caption{Aritmētiski loģiskā ierīce.}
		\label{fig:alu}
	\end{figure}
	
	Lai gan klasiski bīdes operācijas arī tiek realizētas Aritmētiski
	loģiskajā ierīcē, šajā gadījumā ALU veic tikai aritmētiskās un bitu
	loģikas darbības, atstājot bīdes operācijas „bitu bīdes loģiskjai ierīcei”
	(sk.~\ref{sec:shifter}~nod.). Šāda sadalīšana ļauj veikt aritmētiskās
	un bīdes operācijas vienlaicīgi, uz ko balstās \mnem{AR} instrukcija
	(sk.~\ref{sec:AR}~nod.~\pageref{sec:AR}~lpp.)
	
	ALU realizēta kā kombinacionāla shēma ar asinhronu darbību,
	t.i.~izejas vērtība tiek izmainīta uzreiz,
	bez kontroles signāla (takts) pievadīšanas, un izejas vērtība ir tikai
	atkarīga no pievadīto operandu vērtībām, kuru vērtības iekšēji ALU
	netiek saglabātas.
	Lai būtu iespējams veikt darbības ar diviem
	operandiem no operatīvo reģistru masīva, tiek izmantots \texttt{opReg}
	reģistrs viena operanda uzglabāšanai, lai otru varētu nodot tieši.
	(sk.~\ref{fig:cpu-rev3}~att., \pageref{fig:cpu-rev3}~lpp.)
	
	%\begin{singlespace}
		\lstinputlisting[language={[qucs]VHDL},float=t,%
		                caption={ALU VHDL apraksts. (\texttt{alu.vhd})},%
		                label=kb:alu]
			{code/alu.vhd}
	%\end{singlespace}

\pagebreak[3]
\subsubsection{Bitu bīdes loģiskā ierīce} \label{sec:shifter}
	Ierīce, kura šeit nosaukta par ,,bitu bīdes loģisko ierīci'',
	realizē bitu bīdes operācijas kuras	šī procesora realizācijā ir
	izdalītas atsevišķi no ALU. 
	Realizācija, līdzīgi ALU, ir kombinacionāla un asinhrona.

	\begin{figure}[thb]
		\centering
		%\def\svgwidth{7cm}
		\def\svgscale{1.25}
		{\ttfamily\scriptsize\input{img/sub-shift.pdf_tex}}
		\caption{Bitu bīdes loģiskā ierīce.}
		\label{fig:shift}
	\end{figure}
	
	\begin{singlespace}
		\lstinputlisting[language={[qucs]VHDL},%float=pb,%
		                caption={Bīdes ierīces VHDL apraksts. (\texttt{shifter.vhd})},%
		                label=kb:shifter,%
		                tabsize=3%,% TO REDUCE THE CODE WIDTH
		                ]
			{code/shifter.vhd}
	\end{singlespace}

%\clearpage
\pagebreak[3]
\subsubsection{Komparators} \label{sec:comp}
	Komparators jeb salīdzinātājs ir komponente, kas salīdzina 
	divus operandus un izvada tā vienādības vai nevienādības signālu.
	
	Šī komparatora implementācija ir minimizēta, kombinacionāla un nesatur
	kontroles signālus. Izvadīti tiek tikai divi biti, no kuriem viens
	norāda uz operandu vienādību vai nevienādību, savukārt otrs norāda
	vai operands \texttt{a} ir lielāks par \texttt{b} vai nav. Ar šo
	informāciju ir pilnīgi pietiekami, lai būtu iepējams realizēt visas
	nosacījuma zarošanās (\mnem{BRxx}) instrukcijas.
	\begin{figure}[thp]
		\centering
		%\def\svgwidth{7cm}
		\def\svgscale{1.25}
		{\ttfamily\scriptsize\input{img/sub-comp.pdf_tex}}
		\caption{Komparators.}
		\label{fig:comp}
	\end{figure}
	
	\begin{singlespace}
		\lstinputlisting[language={[qucs]VHDL},%float=pb,%
		                caption={Komparatora VHDL apraksts. (\texttt{comp.vhd})},%
		                label=kb:comp]
			{code/comp.vhd}
	\end{singlespace}

\pagebreak[3]
\subsubsection{Kontroles iekārta}
	Viena no procesora definējošām un iespējams sarežģītākajām komponentēm
	— kontroles iekārta ir tā kas nodrošina mikro-operāciju izpildi.
	Kontroles iekārta realizēta kā stāvokļa mašīna, kur katrs stāvoklis
	atbilst mikro-operācijai, un tātad tās VHDL apraksts ir uzskatāms par
	realizētā procesora mikrokodu.
	Kontroles iekārtas VHDL apraksts ir garš un sarežģīts, un tā daļas tiks
	izskatītas instrukciju darbības aprakstos.\\
	(Pilno kodu sk.~pielikumā~\ref{appx:control} \pageref{appx:control}.~lpp.)
	\begin{figure}[h!]
		\centering
		%\def\svgwidth{7cm}
		\def\svgscale{1.1}
		{\ttfamily\scriptsize\input{img/sub-control.pdf_tex}}
		\caption{Kontroles iekārta.}
		\label{fig:control}
	\end{figure}
