\subsubsection{Mašīnmācāma FAST implementācija} \label{sec:fast-original}
Pirmo FAST definīciju Rostens~un~Dramonds piedāvā jau \cite{Rosten-tracking}
publikācijā, bet tās implementācija bija tikai uzlabots segmenta
pārbaudītājs pie minimālā segmenta garuma $n=12$
(citas $n$ vērtības \cite{Rosten-tracking} avotā nemaz netiek apsvērtas).

Tieši Rostena~un~Dramonda sekojošā publikācija par mašīnmācības
izmantošanu FAST algoritma uzlabošanai~\cite{FAST} dod būtisku
ātrdarbības uzlabojumu, un tiek bieži citēta kā ,,oriģinālā'' FAST
implementācija.

Rostena~un~Dramonda\cite{FAST} implementācija balstās uz
mašīnmācību, lai samazinātu nepieciešamo pārbaužu skaitu starp
kandidātu punktu un punktiem no FAST riņķa. Ar mašīnmācīšanos tiek
noskaidroti tie riņķa punkti $c$, kuriem ir vislielākais informatīvais
ieguldījums punktu klasificēšanā pielietojot $F_n$, apmācības attēlu
kopai $\vb{P}$. Pēc apmācības rezultātiem tiek izveidots
,,jautājumu koks'', pēc kura salīdzinājumu (jautājumu) secība tiek
mainīta pēc rezultātiem (atbildēm) kas ļauj veikt klasifikāciju ar
minimālu pārbaužu skaitu. Šis jautājumu koks ir tuva aproksimācija
segmenta testa funkcionalitātei, bet ne pilnīgs tās funkcionālais
ekvivalents, lai gan autors nav konstatējis atšķirības
pārbaužu rezultātos. \cite{FAST}

Izmantojot iegūto jautājumu koku tiek ģenerēts kods, pēc hierarhiālas
struktūras ar pakārtotām \texttt{if\ldots{}else} konstrukcijām C valodā%
\footnote{Rostens arī publicējis ģeneratorus citām programmēšanas valodām},
kura tiešā veidā atveido jautājumu koku. \cite{FAST}

Šī implementācija ir virzīta tieši secīgās izpildes operāciju samazināšanai,
un tādējādi sekmē ātrdarbības uzlabošanu CPU platformai. Autora eksperimentā,
pārbaudot ātrdarbību tika novērots būtisks uzlabojums pār segmenta testu un
arī neapmācītu implementāciju. Tomēr rezultāti salīdzinājumā ar citām
implementācijām nav konsistenti. Implementāciju salīdzinājums ir izvērsts
\ref{sec:fast-compare}~nodaļā
(skatīt arī pielikumu~\ref{appx:test1} darba~\pageref{appx:test1}~lapā).
